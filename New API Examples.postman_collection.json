{
	"info": {
		"_postman_id": "e8d82a10-af66-4caf-bd65-45e358f15dc6",
		"name": "API Examples",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "19427032",
		"_collection_link": "https://fuzable.postman.co/workspace/Skapa-Fuzable~613ae270-db9f-47af-bc90-2eee06cabf28/collection/19665819-e8d82a10-af66-4caf-bd65-45e358f15dc6?action=share&source=collection_link&creator=19427032"
	},
	"item": [
		{
			"name": "Responses",
			"item": [
				{
					"name": "Response is OK",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200\", function () {\r",
									"  pm.response.to.have.status(200);\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{mockUrl}}/courses",
							"host": [
								"{{mockUrl}}"
							],
							"path": [
								"courses"
							]
						}
					},
					"response": []
				},
				{
					"name": "Response time",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Response time is less than 2s\", function () {\r",
									"    pm.expect(pm.response.responseTime).to.be.below(2000);\r",
									"});\r",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{mockUrl}}/courses",
							"host": [
								"{{mockUrl}}"
							],
							"path": [
								"courses"
							]
						}
					},
					"response": []
				},
				{
					"name": "Response size",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Response size within expected range\", function () {\r",
									"    pm.expect(pm.response.responseSize).to.be.gt(3000); // 3 kb\r",
									"    pm.expect(pm.response.responseSize).to.be.lt(100000); // 100 kb\r",
									"});\r",
									"\r",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{mockUrl}}/courses",
							"host": [
								"{{mockUrl}}"
							],
							"path": [
								"courses"
							]
						}
					},
					"response": []
				},
				{
					"name": "Response is not cached",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Check header cache-control is set to no-store\", function () {\r",
									"  let headers = pm.response.headers;\r",
									"  let cache_control = headers.find(o => o.key === \"Cache-Control\");\r",
									"  pm.expect(cache_control.value).eql(\"no-store, must-revalidate, no-cache, max-age=0\");\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "x-mock-response-name",
								"value": "Courses by Release Date",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{mockUrl}}/courses",
							"host": [
								"{{mockUrl}}"
							],
							"path": [
								"courses"
							]
						}
					},
					"response": []
				},
				{
					"name": "Parse value from returned URL",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Parse value from URL (annotated)\", function () {\r",
									"    //import js url package\r",
									"    const URL = require('url');\r",
									"    //get response and inspect\r",
									"    let response = pm.response.json();\r",
									"    pm.expect(response).to.haveOwnProperty(\"url\");\r",
									"    //get url from json\r",
									"    let rawUrl = response.url;\r",
									"    pm.expect(rawUrl).to.eql(\"https://enrollment.course.com/123456/098765\");\r",
									"    //parse using url class\r",
									"    const parsedUrl = URL.parse(rawUrl);\r",
									"    //get path\r",
									"    let path = parsedUrl.pathname;\r",
									"    pm.expect(path).to.eql(\"/123456/098765\");\r",
									"    //split values \r",
									"    var vals = path.split(\"/\");\r",
									"    pm.expect(vals).to.have.lengthOf(3);\r",
									"    pm.expect(vals[1]).to.eql(\"123456\");\r",
									"    pm.expect(vals[2]).to.eql(\"098765\");\r",
									"    //get first value and store off\r",
									"    let value = Number(vals[1]);\r",
									"    pm.expect(value).to.be.a('number');\r",
									"    pm.collectionVariables.set('parsedUrlValue', value);\r",
									"});\r",
									"\r",
									"/*\r",
									"reference:\r",
									"https://javascript.info/url\r",
									"https://github.com/postmanlabs/postman-app-support/issues/3059\r",
									"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split\r",
									"https://www.w3schools.com/jsref/jsref_number.asp\r",
									"*/\r",
									"\r",
									"pm.test(\"Parse value from URL\", () => {\r",
									"    //use url lib\r",
									"    const URL = require('url');\r",
									"    //get url and parse id\r",
									"    let response = pm.response.json();\r",
									"    pm.expect(response).to.haveOwnProperty(\"url\");\r",
									"    let rawUrl = response.url;\r",
									"    const parsedUrl = URL.parse(rawUrl);\r",
									"    let path = parsedUrl.pathname;\r",
									"    //format of path is like \"/1234/1234\"\r",
									"    var vals = path.split(\"/\");\r",
									"    pm.expect(vals).to.have.lengthOf(3);\r",
									"    //get first actual value to use later\r",
									"    let value = Number(vals[1]);\r",
									"    pm.collectionVariables.set('parsedUrlValue', value);\r",
									"});\r",
									"\r",
									"\r",
									"\r",
									"\r",
									"\r",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "x-mock-response-name",
								"value": "Stub URL",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{mockUrl}}/stubs",
							"host": [
								"{{mockUrl}}"
							],
							"path": [
								"stubs"
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "Json",
			"item": [
				{
					"name": "Get number of items returned",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Responses returns expected number of items\", () => {\r",
									"    let response = pm.response.json();\r",
									"    pm.expect(response).to.have.property(\"data\");\r",
									"    const data = response.data;\r",
									"    pm.expect(data).to.be.an(\"array\");\r",
									"    //multiple ways to check\r",
									"    pm.expect(data.length).to.eql(5);\r",
									"    pm.expect(data.count()).to.eql(5);\r",
									"    pm.expect(data.length).to.be.lessThan(10);\r",
									"    pm.expect(data.length).to.be.greaterThan(1);\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "x-mock-response-name",
								"value": "Courses by Release Date",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{mockUrl}}/courses",
							"host": [
								"{{mockUrl}}"
							],
							"path": [
								"courses"
							]
						}
					},
					"response": []
				},
				{
					"name": "Check data types",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"//schema check does a more thorough job of this, \r",
									"//but sometimes maybe useful to check this way\r",
									"\r",
									"pm.test(\"Data types are as expected\", () => {\r",
									"    let response = pm.response.json();    \r",
									"    pm.expect(response.courseEnrollmentId).to.be.null;\r",
									"    pm.expect(response.courseCode).to.be.a('string');\r",
									"    pm.expect(response.duration).to.be.a('number');\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "x-mock-response-name",
								"value": "Stub Course",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{mockUrl}}/stubs",
							"host": [
								"{{mockUrl}}"
							],
							"path": [
								"stubs"
							]
						}
					},
					"response": []
				},
				{
					"name": "Get first object in array",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"First item is as expected\", () => {\r",
									"    let response = pm.response.json();\r",
									"    pm.expect(response).to.have.property(\"data\");\r",
									"    const data = response.data;\r",
									"    pm.expect(data).to.be.an(\"array\");\r",
									"    //first element in array\r",
									"    let first = data[0];\r",
									"    pm.expect(first).courseCode = \"REL-AHC-CTU-43-05\";\r",
									"    //can also use first() method\r",
									"    let alsoFirst = data.first();\r",
									"    pm.expect(alsoFirst).courseCode = \"REL-AHC-CTU-43-05\";\r",
									"    //first can also have a function\r",
									"    //in this case, returns first match\r",
									"    let matchingFirst = data.first(o => o.courseCode === \"REL-AHC-CTU-43-03\");\r",
									"    pm.expect(matchingFirst).courseCode = \"REL-AHC-CTU-43-03\";\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "x-mock-response-name",
								"value": "Courses by Release Date",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{mockUrl}}/courses",
							"host": [
								"{{mockUrl}}"
							],
							"path": [
								"courses"
							]
						}
					},
					"response": []
				},
				{
					"name": "Find specific object in array",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Expected exists in response\", () => {\r",
									"    let response = pm.response.json();\r",
									"    pm.expect(response).to.have.property(\"data\");\r",
									"    const data = response.data;\r",
									"    pm.expect(data).to.be.an(\"array\");\r",
									"    let expected = data.find(x => x.courseId === 8211);\r",
									"    pm.expect(expected).length === 1;\r",
									"    pm.expect(expected.courseCode === \"REL-AHC-CTU-43-04\");\r",
									"    //can also use first, to return first match (vs all matches)\r",
									"    //count will always be 1 (or 0, if not found)\r",
									"    let alsoExpected = data.first(x => x.courseId === 8211);\r",
									"    pm.expect(alsoExpected.courseCode === \"REL-AHC-CTU-43-04\");\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "x-mock-response-name",
								"value": "Courses by Release Date",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{mockUrl}}/courses",
							"host": [
								"{{mockUrl}}"
							],
							"path": [
								"courses"
							]
						}
					},
					"response": []
				},
				{
					"name": "Ensure specific object does not exist",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Response does not contain item\", () => {\r",
									"    let response = pm.response.json();\r",
									"    pm.expect(response).to.have.property(\"data\");\r",
									"    const data = response.data;\r",
									"    pm.expect(data).to.be.an(\"array\");\r",
									"    let expected = data.find(x => x.courseId === 19999);\r",
									"    //multiple ways to check\r",
									"    pm.expect(expected).to.be.undefined;\r",
									"    pm.expect(expected).length === 0;\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "x-mock-response-name",
								"value": "Courses by Release Date",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{mockUrl}}/courses",
							"host": [
								"{{mockUrl}}"
							],
							"path": [
								"courses"
							]
						}
					},
					"response": []
				},
				{
					"name": "Objects are ordered by date",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"//response must have a data property\r",
									"//checked when checking dates, extracted here for clarity\r",
									"pm.test(\"Response returned objects (partial)\", () => {\r",
									"    let response = pm.response.json();\r",
									"    pm.expect(response).to.have.property(\"data\");\r",
									"});\r",
									"\r",
									"//data must have records or dates to check\r",
									"//checked when checking dates, extracted here for clarity\r",
									"pm.test(\"Data has elements (partial)\", () => {\r",
									"    let response = pm.response.json();\r",
									"    pm.expect(response).to.have.property(\"data\");\r",
									"    const data = response.data;\r",
									"    pm.expect(data).to.be.an(\"array\");\r",
									"    pm.expect(data).length.is.greaterThan(0);\r",
									"});\r",
									"\r",
									"//actually check data's date order, in this case releasedate\r",
									"pm.test(\"Release dates are most recent first (annotated)\", () => {\r",
									"    //verify there is data\r",
									"    let response = pm.response.json();\r",
									"    pm.expect(response).to.have.property(\"data\");\r",
									"    const data = response.data;\r",
									"    pm.expect(data).to.be.an(\"array\");\r",
									"    pm.expect(data).length.is.greaterThan(0);\r",
									"    //extract and format all release dates for comparison\r",
									"    //use momentjs \r",
									"    let moment = require(\"moment\");\r",
									"    //format as sortable string\r",
									"    let dates = data.map(o => moment(o.releaseDate).format(\"YYYYMMDD\"));\r",
									"    //verify the dates are in descending order\r",
									"    //specifically, verify each subsequent date after the first\r",
									"    //is less than or equal to the date before it in the array\r",
									"    const isDesc = dates.every((x, i, d) => i === 0 || x <= d[i-1]);\r",
									"    pm.expect(isDesc).to.be.true;\r",
									"});\r",
									"\r",
									"/* reference:\r",
									"https://momentjscom.readthedocs.io/en/latest/moment/04-displaying/01-format/\r",
									"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map\r",
									"*/\r",
									"\r",
									"pm.test(\"Release dates are most recent first\", () => {\r",
									"    let response = pm.response.json();\r",
									"    pm.expect(response).to.have.property(\"data\");\r",
									"    const data = response.data;\r",
									"    pm.expect(data).length.is.greaterThan(0);\r",
									"    //format and extract dates to compare\r",
									"    let moment = require(\"moment\");\r",
									"    let dates = data.map(o => moment(o.releaseDate).format(\"YYYYMMDD\"));\r",
									"    const isDesc = dates.every((x, i, d) => i === 0 || x <= d[i-1]);\r",
									"    pm.expect(isDesc).to.be.true;\r",
									"});\r",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "x-mock-response-name",
								"value": "Courses by Release Date",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{mockUrl}}/courses",
							"host": [
								"{{mockUrl}}"
							],
							"path": [
								"courses"
							]
						}
					},
					"response": []
				},
				{
					"name": "Objects are ordered by date (asc) via x-sort",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"//NOTE:\r",
									"//see pre-request script to set x-sort\r",
									"//encoded sort is stored in variable, set in pre-request \r",
									"//this sort variable is referenced in headers\r",
									"\r",
									"//response must have a data property\r",
									"//checked when checking dates, extracted here for clarity\r",
									"pm.test(\"Response returned objects (partial)\", () => {\r",
									"    let response = pm.response.json();\r",
									"    pm.expect(response).to.have.property(\"data\");\r",
									"});\r",
									"\r",
									"//data must have records or dates to check\r",
									"//checked when checking dates, extracted here for clarity\r",
									"pm.test(\"Data has elements (partial)\", () => {\r",
									"    let response = pm.response.json();\r",
									"    pm.expect(response).to.have.property(\"data\");\r",
									"    const data = response.data;\r",
									"    pm.expect(data).to.be.an(\"array\");\r",
									"    pm.expect(data).length.is.greaterThan(0);\r",
									"});\r",
									"\r",
									"//actually check data's date order, in this case releasedate\r",
									"pm.test(\"Archive dates are most recent first (annotated)\", () => {\r",
									"    //verify there is data\r",
									"    let response = pm.response.json();\r",
									"    pm.expect(response).to.have.property(\"data\");\r",
									"    const data = response.data;\r",
									"    pm.expect(data).to.be.an(\"array\");\r",
									"    pm.expect(data).length.is.greaterThan(0);\r",
									"    //extract and format dates for comparison\r",
									"    //use momentjs \r",
									"    let moment = require(\"moment\");\r",
									"    //format dates as sortable string\r",
									"    let dates = data.map(o => moment(o.archiveDate).format(\"YYYYMMDD\"));\r",
									"    //verify the dates are in descending order\r",
									"    //specifically, verify each subsequent date after the first\r",
									"    //is greater than or equal to the date before it in the array\r",
									"    const isAsc = dates.every((x, i, d) => i === 0 || x >= d[i - 1]);\r",
									"    pm.expect(isAsc).to.be.true;\r",
									"});\r",
									"\r",
									"/* reference:\r",
									"https://momentjscom.readthedocs.io/en/latest/moment/04-displaying/01-format/\r",
									"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map\r",
									"*/\r",
									"\r",
									"pm.test(\"Archive dates are most recent first\", () => {\r",
									"    let response = pm.response.json();\r",
									"    pm.expect(response).to.have.property(\"data\");\r",
									"    const data = response.data;\r",
									"    pm.expect(data).to.be.an(\"array\");\r",
									"    pm.expect(data).length.is.greaterThan(0);\r",
									"    //format and extract dates to compare\r",
									"    let moment = require(\"moment\");\r",
									"    let dates = data.map(o => moment(o.archiveDate).format(\"YYYYMMDD\"));\r",
									"    const isAsc = dates.every((x, i, d) => i === 0 || x >= d[i - 1]);\r",
									"    pm.expect(isAsc).to.be.true;\r",
									"});"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"//create sort header\r",
									"var CryptoJS = require(\"crypto-js\")\r",
									"var sortExpiry = [{\r",
									"    \"fieldName\": \"archiveDate\",\r",
									"    \"sortOrder\": 1\r",
									"}];\r",
									"pm.collectionVariables.set(\"sortHeader\",\r",
									"    CryptoJS.enc.Base64.stringify(CryptoJS.enc.Utf8.parse(JSON.stringify(sortExpiry)))\r",
									");\r",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "x-sort",
								"value": "{{sortHeader}}",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{mockUrl}}/courses",
							"host": [
								"{{mockUrl}}"
							],
							"path": [
								"courses"
							]
						}
					},
					"response": []
				},
				{
					"name": "Property in each object contains value",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"//response must have a data property\r",
									"//checked later too, extracted here for clarity\r",
									"pm.test(\"Response returned objects (partial)\", () => {\r",
									"    let response = pm.response.json();\r",
									"    pm.expect(response).to.have.property(\"data\");\r",
									"});\r",
									"\r",
									"//data must have records or dates to check\r",
									"//checked later too, extracted here for clarity\r",
									"pm.test(\"Data has elements (partial)\", () => {\r",
									"    let response = pm.response.json();\r",
									"    pm.expect(response).to.have.property(\"data\");\r",
									"    const data = response.data;\r",
									"    pm.expect(data).to.be.an(\"array\");\r",
									"    pm.expect(data).length.is.greaterThan(0);\r",
									"});\r",
									"\r",
									"//actually check all object's specific property for a value, in this case title\r",
									"pm.test(\"Title contains value (annotated)\", () => {\r",
									"    //verify response contains data and data has elements\r",
									"    let response = pm.response.json();\r",
									"    pm.expect(response).to.have.property(\"data\");\r",
									"    const data = response.data;\r",
									"    pm.expect(data).to.be.an(\"array\");\r",
									"    pm.expect(data).length.is.greaterThan(0);\r",
									"    //probably get the value to search for from a variable\r",
									"    //let val = pm.collectionVariables.get(\"validVolumeNo\");\r",
									"    //...but we will just set it here for simplicity\r",
									"    let val = \"43\";\r",
									"    //using underscorejs, does not need to extract to array using map\r",
									"    //data is all objects, and (item) is each item to check\r",
									"    _.each(data, (item) => {\r",
									"        pm.expect(item.courseTitle).to.contain(val);\r",
									"    })\r",
									"    //or, extract to array first using map\r",
									"    //as when checking by dates (see \"Objects are ordered by date\")\r",
									"    //and use array's every method  \r",
									"    let titles = data.map(o => o.courseTitle); \r",
									"    const valExists = titles.every((x) => x.includes(val));\r",
									"    pm.expect(valExists).to.be.true;\r",
									"});\r",
									"\r",
									"/* reference:\r",
									"https://www.tutorialspoint.com/underscorejs/underscorejs_each.htm\r",
									"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map\r",
									"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every\r",
									"*/\r",
									"\r",
									"pm.test(\"Title contains value\", () => {\r",
									"    let response = pm.response.json();\r",
									"    pm.expect(response).to.have.property(\"data\");\r",
									"    const data = response.data;\r",
									"    pm.expect(data).to.be.an(\"array\");\r",
									"    pm.expect(data).length.is.greaterThan(0);\r",
									"    let val = \"43\";\r",
									"    _.each(data, (item) => {\r",
									"        pm.expect(item.courseTitle).to.contain(val);\r",
									"    })\r",
									"});\r",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "x-mock-response-name",
								"value": "Courses by Release Date",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{mockUrl}}/courses",
							"host": [
								"{{mockUrl}}"
							],
							"path": [
								"courses"
							]
						}
					},
					"response": []
				},
				{
					"name": "Property in each object is the same value",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"//verify all objects' libraryIds are the same value\r",
									"pm.test(\"Property matches value (annotated)\", () => {\r",
									"    let response = pm.response.json();\r",
									"    pm.expect(response).to.have.property(\"data\");\r",
									"    const data = response.data;\r",
									"    pm.expect(data).length.is.greaterThan(0);\r",
									"    //extract all ids to an array using map\r",
									"    let ids = response.data.map(o => o.libraryId);\r",
									"    //value to compare against is probably in variables\r",
									"    //let pubId = pm.collectionVariables.get(\"validLibraryId\");\r",
									"    let pubId = \"248\";\r",
									"    //use every function of array to test that they all match\r",
									"    const isMatch = ids.every((x) => x == pubId);\r",
									"    pm.expect(isMatch).to.be.true;\r",
									"});\r",
									"\r",
									"/* reference:\r",
									"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map\r",
									"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every\r",
									"*/\r",
									"\r",
									"pm.test(\"Property matches value\", () => {\r",
									"    let response = pm.response.json();\r",
									"    pm.expect(response).to.have.property(\"data\");\r",
									"    const data = response.data;\r",
									"    pm.expect(data).length.is.greaterThan(0);\r",
									"    let ids = response.data.map(o => o.libraryId);\r",
									"    let pubId = \"248\";\r",
									"    const isMatch = ids.every((x) => x == pubId);\r",
									"    pm.expect(isMatch).to.be.true;\r",
									"});\r",
									"\r",
									"\r",
									""
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "x-mock-response-name",
								"value": "Courses for Publication",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{mockUrl}}/courses",
							"host": [
								"{{mockUrl}}"
							],
							"path": [
								"courses"
							]
						}
					},
					"response": []
				},
				{
					"name": "Compare object to example",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"//define (or retrieve) example\r",
									"let expected = {\r",
									"    \"userId\": 72688,\r",
									"    \"fieldName\": \"AbimIdNumber\",\r",
									"    \"fieldValue\": \"654321\"\r",
									"}\r",
									"\r",
									"pm.test(\"Response matches example (compare objects as strings)\", () => {\r",
									"    let response = JSON.stringify(pm.response.json());\r",
									"    pm.expect(response).to.equal(JSON.stringify(expected));\r",
									"});\r",
									"\r",
									"pm.test(\"Response matches example (compare properties)\", () => {\r",
									"    let response = pm.response.json();\r",
									"    for (let key in expected) {\r",
									"        pm.expect(response[key]).eql(expected[key])\r",
									"    }\r",
									"});\r",
									"\r",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "x-mock-response-name",
								"value": "Stub User",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{mockUrl}}/userstub",
							"host": [
								"{{mockUrl}}"
							],
							"path": [
								"userstub"
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "Sort and Filter",
			"item": [
				{
					"name": "Configure x-sort",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"//NOTE:\r",
									"//see pre-request script to set x-sort\r",
									"//encoded sort is stored in variable, set in pre-request \r",
									"//this sort variable is referenced in headers\r",
									"\r",
									"//the tests below is not needed in any tests for skapa\r",
									"//is just to verify pre-request is working properly \r",
									"pm.test(\"x-sort is configured\", () => {\r",
									"    let actualSort = pm.request.headers.find(h => h.key == \"x-sort\").value;\r",
									"    let intendedSort = pm.collectionVariables.get(\"sortHeader\");\r",
									"    pm.expect(actualSort).to.eql(intendedSort);\r",
									"});\r",
									"\r",
									"pm.test(\"x-sort configuration matches intention\", () => {\r",
									"    let sortHeader = pm.request.headers.find(h => h.key == \"x-sort\").value; \r",
									"    let actualSort = CryptoJS.enc.Utf8.stringify(CryptoJS.enc.Base64.parse(sortHeader)); \r",
									"    var sort = [{\r",
									"        \"fieldName\": \"archiveDate\",\r",
									"        \"sortOrder\": 1\r",
									"    }];\r",
									"    pm.expect(actualSort).to.eql(JSON.stringify(sort));\r",
									"});\r",
									"\r",
									"//reference:\r",
									"//https://stackoverflow.com/questions/25492179/decode-a-base64-string-using-cryptojs\r",
									""
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"//encode sort filter using cryptojs\r",
									"var CryptoJS = require(\"crypto-js\")\r",
									"var sortExpiry = [{\r",
									"    \"fieldName\": \"archiveDate\",\r",
									"    \"sortOrder\": 1\r",
									"}];\r",
									"//stringify the json object\r",
									"let sortDef = JSON.stringify(sortExpiry);\r",
									"//parse the json string to utf-8\r",
									"let sortUtf8 = CryptoJS.enc.Utf8.parse(sortDef);\r",
									"//encode to base64\r",
									"let sortEnc = CryptoJS.enc.Base64.stringify(sortUtf8);\r",
									"//store encoded sort as variable for use in header\r",
									"pm.collectionVariables.set(\"sortHeader\", sortEnc);\r",
									"\r",
									"/* reference:\r",
									"https://en.wikipedia.org/wiki/UTF-8\r",
									"https://cryptojs.gitbook.io/docs/\r",
									"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify\r",
									"*/\r",
									"\r",
									"//create sort header\r",
									"var CryptoJS = require(\"crypto-js\")\r",
									"var sortExpiry = [{\r",
									"    \"fieldName\": \"archiveDate\",\r",
									"    \"sortOrder\": 1\r",
									"}];\r",
									"pm.collectionVariables.set(\"sortHeader\",\r",
									"    CryptoJS.enc.Base64.stringify(CryptoJS.enc.Utf8.parse(JSON.stringify(sortExpiry)))\r",
									");\r",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "x-sort",
								"value": "{{sortHeader}}",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{mockUrl}}/courses",
							"host": [
								"{{mockUrl}}"
							],
							"path": [
								"courses"
							]
						}
					},
					"response": []
				},
				{
					"name": "Configure x-filter",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"//NOTE:\r",
									"//see pre-request script to set x-filter\r",
									"//encoded filter is stored in variable, set in pre-request \r",
									"//this filter variable is referenced in headers\r",
									"\r",
									"//the tests below is not needed in any tests for skapa\r",
									"//is just to verify pre-request is working properly \r",
									"pm.test(\"x-filter is configured\", () => {\r",
									"    let actualFilter = pm.request.headers.find(h => h.key == \"x-filter\").value;\r",
									"    let intendedFilter = pm.collectionVariables.get(\"filterHeader\");\r",
									"    pm.expect(actualFilter).to.eql(intendedFilter);\r",
									"});\r",
									"\r",
									"pm.test(\"x-filter configuration matches intention\", () => {\r",
									"    let filterHeader = pm.request.headers.find(h => h.key == \"x-filter\").value;\r",
									"    let actualFilter = CryptoJS.enc.Utf8.stringify(CryptoJS.enc.Base64.parse(filterHeader));\r",
									"    var filter = [{\r",
									"        \"fieldNames\": [\"searchQuery\"],\r",
									"        \"filterType\": 3,\r",
									"        \"matches\": [\"43\"]\r",
									"    }];\r",
									"    pm.expect(actualFilter).to.eql(JSON.stringify(filter));\r",
									"});\r",
									"\r",
									"//reference:\r",
									"//https://stackoverflow.com/questions/25492179/decode-a-base64-string-using-cryptojs\r",
									"\r",
									""
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"//encode filter filter using cryptojs\r",
									"var CryptoJS = require(\"crypto-js\")\r",
									"//probably have what to filter on in a variable\r",
									"//let match = pm.collectionVariables.get(\"match\");\r",
									"//...but we can just set as var\r",
									"let match = \"43\";\r",
									"var filter = [{\r",
									"    \"fieldNames\": [\"searchQuery\"],\r",
									"    \"filterType\": 3,\r",
									"    \"matches\": [match]\r",
									"}];\r",
									"//stringify the json object\r",
									"let filterDef = JSON.stringify(filter);\r",
									"//parse the json string to utf-8\r",
									"let filterUtf8 = CryptoJS.enc.Utf8.parse(filterDef);\r",
									"//encode to base64\r",
									"let filterEnc = CryptoJS.enc.Base64.stringify(filterUtf8);\r",
									"//store encoded sort as variable for use in header\r",
									"pm.collectionVariables.set(\"filterHeader\", filterEnc);\r",
									"\r",
									"/* reference:\r",
									"https://en.wikipedia.org/wiki/UTF-8\r",
									"https://cryptojs.gitbook.io/docs/\r",
									"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify\r",
									"*/\r",
									"\r",
									"//create filter header\r",
									"var CryptoJS = require(\"crypto-js\")\r",
									"let searchFor = \"43\";\r",
									"var filter = [{\r",
									"    \"fieldNames\": [\"searchQuery\"],\r",
									"    \"filterType\": 3,\r",
									"    \"matches\": [searchFor]\r",
									"}];\r",
									"pm.collectionVariables.set(\"filterHeader\",\r",
									"    CryptoJS.enc.Base64.stringify(CryptoJS.enc.Utf8.parse(JSON.stringify(filter)))\r",
									");\r",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "x-filter",
								"value": "{{filterHeader}}",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{mockUrl}}/courses",
							"host": [
								"{{mockUrl}}"
							],
							"path": [
								"courses"
							]
						}
					},
					"response": []
				},
				{
					"name": "Configure empty x-filter (no filter)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"//NOTE:\r",
									"//see pre-request script to set x-filter\r",
									"//encoded filter is stored in variable, set in pre-request \r",
									"//this filter variable is referenced in headers\r",
									"\r",
									"//the tests below is not needed in any tests for skapa\r",
									"//is just to verify pre-request is working properly \r",
									"pm.test(\"x-filter is configured\", () => {\r",
									"    let actualFilter = pm.request.headers.find(h => h.key == \"x-filter\").value;\r",
									"    let intendedFilter = pm.collectionVariables.get(\"filterHeader\");\r",
									"    pm.expect(actualFilter).to.eql(intendedFilter);\r",
									"});\r",
									"\r",
									"pm.test(\"x-filter configuration matches intention\", () => {\r",
									"    let filterHeader = pm.request.headers.find(h => h.key == \"x-filter\").value;\r",
									"    let actualFilter = CryptoJS.enc.Utf8.stringify(CryptoJS.enc.Base64.parse(filterHeader));\r",
									"    var filter = [];\r",
									"    pm.expect(actualFilter).to.eql(JSON.stringify(filter));\r",
									"});\r",
									"\r",
									"//reference:\r",
									"//https://stackoverflow.com/questions/25492179/decode-a-base64-string-using-cryptojs\r",
									"\r",
									""
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"//create filter header, no filter\r",
									"var CryptoJS = require(\"crypto-js\")\r",
									"var filter = [];\r",
									"var filterParsed = CryptoJS.enc.Utf8.parse(JSON.stringify(filter));\r",
									"var filterHeader = CryptoJS.enc.Base64.stringify(filterParsed);\r",
									"pm.collectionVariables.set(\"filterHeader\", filterHeader);  \r",
									"\r",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "x-filter",
								"value": "{{filterHeader}}",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{mockUrl}}/courses",
							"host": [
								"{{mockUrl}}"
							],
							"path": [
								"courses"
							]
						}
					},
					"response": []
				},
				{
					"name": "Configure x-filter and x-sort",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"//NOTE:\r",
									"//see pre-request script to set x-sort and x-filter\r",
									"//encoded sort is stored in variables, referenced in headers\r",
									"\r",
									"//the tests below is not needed in any tests for skapa\r",
									"//is just to verify pre-request is working properly \r",
									"pm.test(\"x-sort is configured\", () => {\r",
									"    let actualSort = pm.request.headers.find(h => h.key == \"x-sort\").value;\r",
									"    let intendedSort = pm.collectionVariables.get(\"sortHeader\");\r",
									"    pm.expect(actualSort).to.eql(intendedSort);\r",
									"});\r",
									"\r",
									"pm.test(\"x-sort configuration matches intention\", () => {\r",
									"    let sortHeader = pm.request.headers.find(h => h.key == \"x-sort\").value;\r",
									"    let actualSort = CryptoJS.enc.Utf8.stringify(CryptoJS.enc.Base64.parse(sortHeader));\r",
									"    var sort = [{\r",
									"        \"fieldName\": \"releaseDate\",\r",
									"        \"sortOrder\": 2\r",
									"    }];\r",
									"    pm.expect(actualSort).to.eql(JSON.stringify(sort));\r",
									"});\r",
									"\r",
									"pm.test(\"x-filter is configured\", () => {\r",
									"    let actualFilter = pm.request.headers.find(h => h.key == \"x-filter\").value;\r",
									"    let intendedFilter = pm.collectionVariables.get(\"filterHeader\");\r",
									"    pm.expect(actualFilter).to.eql(intendedFilter);\r",
									"});\r",
									"\r",
									"pm.test(\"x-filter configuration matches intention\", () => {\r",
									"    let filterHeader = pm.request.headers.find(h => h.key == \"x-filter\").value;\r",
									"    let actualFilter = CryptoJS.enc.Utf8.stringify(CryptoJS.enc.Base64.parse(filterHeader));\r",
									"    var filter = [{\r",
									"        \"fieldNames\": [\"searchQuery\"],\r",
									"        \"filterType\": 3,\r",
									"        \"matches\": [43]\r",
									"    }];\r",
									"    pm.expect(actualFilter).to.eql(JSON.stringify(filter));\r",
									"});\r",
									"\r",
									"//reference:\r",
									"//https://stackoverflow.com/questions/25492179/decode-a-base64-string-using-cryptojs\r",
									"\r",
									""
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"//define and encode headers\r",
									"var CryptoJS = require(\"crypto-js\")\r",
									"//filter \r",
									"let vol = 43;\r",
									"//filter\r",
									"var filter = [{\r",
									"    \"fieldNames\": [\"searchQuery\"],\r",
									"    \"filterType\": 3,\r",
									"    \"matches\": [vol]\r",
									"}];\r",
									"pm.collectionVariables.set(\"filterHeader\",\r",
									"    CryptoJS.enc.Base64.stringify(CryptoJS.enc.Utf8.parse(JSON.stringify(filter)))\r",
									");\r",
									"//sort\r",
									"var sort = [{\r",
									"    \"fieldName\": \"releaseDate\",\r",
									"    \"sortOrder\": 2\r",
									"}];\r",
									"pm.collectionVariables.set(\"sortHeader\",\r",
									"    CryptoJS.enc.Base64.stringify(CryptoJS.enc.Utf8.parse(JSON.stringify(sort)))\r",
									");\r",
									"\r",
									"\r",
									"\r",
									"\r",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "x-sort",
								"value": "{{sortHeader}}",
								"type": "text"
							},
							{
								"key": "x-filter",
								"value": "{{filterHeader}}",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{mockUrl}}/courses",
							"host": [
								"{{mockUrl}}"
							],
							"path": [
								"courses"
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "Dates",
			"item": [
				{
					"name": "Creating dates with Moment",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"/* consider doing most everything with dates using moment\r",
									"reference:\r",
									"https://momentjs.com/guides/\r",
									"\r",
									"for comparison, dates in js, no external libs\r",
									"var basicDate = new Date('1/1/2016');\r",
									"var nextDecember3rd = new Date((today.getFullYear()+1).toString() + \"-12-03\");\r",
									"*/\r",
									"\r",
									"//using momentjs\r",
									"let moment = require('moment');\r",
									"\r",
									"//examples of defining dates\r",
									"let today = new moment().format(\"YYYY-MM-DD\");\r",
									"let yesterday = new moment().add(-1, 'days').format(\"YYYY-MM-DD\");\r",
									"let startOfThisMonth = new moment().startOf('month').format(\"YYYY-MM-DD\");\r",
									"let startOfLastMonth = new moment().add(-1, 'months').startOf('month').format(\"YYYY-MM-DD\");\r",
									"let endOfLastMonth = new moment().add(-1, 'months').endOf('month').format(\"YYYY-MM-DD\");\r",
									"let endOfNextMonth = new moment().add(1, 'months').endOf('month').format(\"YYYY-MM-DD\");\r",
									"let startOfMonthAsOf7DaysAgo = new moment().add(-7, 'days').startOf('month').format(\"YYYY-MM-DD\");\r",
									"let startOfMonth14DaysFromNow = new moment().add(14, 'days').startOf('month').format(\"YYYY-MM-DD\");\r",
									"let startOfWeek = new moment().startOf('week').format(\"YYYY-MM-DD\");\r",
									"//note: first day of week is sunday by default, use isoWeek for monday\r",
									"let startOfWeekMonday = new moment().startOf('isoWeek').format(\"YYYY-MM-DD\");\r",
									"let tomorrowAt640AM = new moment().startOf('day').utc().add(1, 'day').add(6, 'hours').add(40, 'minutes');\r",
									"let tomorrowAtNoon = new moment().startOf('day').utc().add(1, 'day').add(12, 'hours');\r",
									"\r",
									"\r",
									"\r",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "x-mock-response-name",
								"value": "Stub Course",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{mockUrl}}/stubs",
							"host": [
								"{{mockUrl}}"
							],
							"path": [
								"stubs"
							]
						}
					},
					"response": []
				},
				{
					"name": "Date is after specified date",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"//using momentjs\r",
									"let moment = require('moment');\r",
									"\r",
									"pm.test(\"Release date is this week (annotated)\", () => {\r",
									"    let response = pm.response.json();    \r",
									"    //create date from response as moment\r",
									"    let date = new moment(response.releaseDate);\r",
									"    //create date to compare against\r",
									"    let startOfWeek = new moment().startOf('week').format(\"YYYY-MM-DD\");\r",
									"    //compare dates using moment\r",
									"    let after = date.isAfter(startOfWeek);\r",
									"    pm.expect(after).to.be.true;\r",
									"});\r",
									"\r",
									"//reference: https://momentjscom.readthedocs.io/en/latest/moment/05-query/03-is-after/\r",
									"\r",
									"pm.test(\"Release date is this week\", () => {\r",
									"    let response = pm.response.json();\r",
									"    let startOfWeek = new moment().startOf('week').format(\"YYYY-MM-DD\");\r",
									"    pm.expect(moment(response.releaseDate).isAfter(startOfWeek)).to.be.true;\r",
									"});\r",
									"\r",
									"\r",
									"\r",
									"\r",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "x-mock-response-name",
								"value": "Stub Course",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{mockUrl}}/stubs",
							"host": [
								"{{mockUrl}}"
							],
							"path": [
								"stubs"
							]
						}
					},
					"response": []
				},
				{
					"name": "Objects are ordered by date (copy)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"//response must have a data property\r",
									"//checked when checking dates, extracted here for clarity\r",
									"pm.test(\"Response returned objects (partial)\", () => {\r",
									"    let response = pm.response.json();\r",
									"    pm.expect(response).to.have.property(\"data\");\r",
									"});\r",
									"\r",
									"//data must have records or dates to check\r",
									"//checked when checking dates, extracted here for clarity\r",
									"pm.test(\"Data has elements (partial)\", () => {\r",
									"    let response = pm.response.json();\r",
									"    pm.expect(response).to.have.property(\"data\");\r",
									"    const data = response.data;\r",
									"    pm.expect(data).length.is.greaterThan(0);\r",
									"});\r",
									"\r",
									"//actually check data's date order, in this case releasedate\r",
									"pm.test(\"Release dates are most recent first (annotated)\", () => {\r",
									"    //verify there is data\r",
									"    let response = pm.response.json();\r",
									"    pm.expect(response).to.have.property(\"data\");\r",
									"    const data = response.data;\r",
									"    pm.expect(data).length.is.greaterThan(0);\r",
									"    //extract and format all release dates for comparison\r",
									"    //use momentjs \r",
									"    let moment = require(\"moment\");\r",
									"    //format as sortable string\r",
									"    let dates = data.map(o => moment(o.releaseDate).format(\"YYYYMMDD\"));\r",
									"    //verify the dates are in descending order\r",
									"    //specifically, verify each subsequent date after the first\r",
									"    //is less than or equal to the date before it in the array\r",
									"    const isDesc = dates.every((x, i, d) => i === 0 || x <= d[i-1]);\r",
									"    pm.expect(isDesc).to.be.true;\r",
									"});\r",
									"\r",
									"/* reference:\r",
									"https://momentjscom.readthedocs.io/en/latest/moment/04-displaying/01-format/\r",
									"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map\r",
									"*/\r",
									"\r",
									"pm.test(\"Release dates are most recent first\", () => {\r",
									"    let response = pm.response.json();\r",
									"    pm.expect(response).to.have.property(\"data\");\r",
									"    const data = response.data;\r",
									"    pm.expect(data).length.is.greaterThan(0);\r",
									"    //format and extract dates to compare\r",
									"    let moment = require(\"moment\");\r",
									"    let dates = data.map(o => moment(o.releaseDate).format(\"YYYYMMDD\"));\r",
									"    const isDesc = dates.every((x, i, d) => i === 0 || x <= d[i-1]);\r",
									"    pm.expect(isDesc).to.be.true;\r",
									"});\r",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "x-mock-response-name",
								"value": "Courses by Release Date",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{mockUrl}}/courses",
							"host": [
								"{{mockUrl}}"
							],
							"path": [
								"courses"
							]
						}
					},
					"response": []
				}
			]
		}
	],
	"variable": [
		{
			"key": "sortHeader",
			"value": ""
		},
		{
			"key": "filterHeader",
			"value": ""
		},
		{
			"key": "UrlNumberValue",
			"value": ""
		},
		{
			"key": "parsedUrlValue",
			"value": ""
		}
	]
}